// Ultra-Realistic Holographic Shader for Trading Card Effects
// Texture d'entrée (bitmap/image)
uniform shader inputShader;

// Paramètres de base
uniform float2 uResolution;
uniform float uAspectRatio;
uniform float uTime;

// Capteurs de tilt
uniform float uTiltPitch;
uniform float uTiltRoll;

// Effets principaux
uniform float uEffectIntensity;
uniform float uShininess;
uniform float uRoughness;
uniform float uFresnelPower;

// Rainbow et spectre
uniform float uRainbowScale;
uniform float uRainbowOffset;
uniform float uSpectrumLayers;

// Normales et micro-relief
uniform float uNormalStrength;
uniform float uMicroDetailScale;

// Subsurface scattering
uniform float uSubsurfaceStrength;
uniform float uSubsurfaceThickness;

// Motifs et détails
uniform float uPatternDensity;
uniform float uPatternVisibility;

// Paillettes
uniform float uSparkleDensity;
uniform float uSparklePower;
uniform float uSparkleIntensity;
uniform float uSparkleSpeed;

// Aberration chromatique
uniform float uChromaticAberrationStrength;

// Animation
uniform float uAnimationSpeed;
uniform float uPulseIntensity;

// Constantes
float PI = 3.141592653589793;

/**
 * Générateur de bruit haute qualité
 */
float hash(float2 p) {
    return fract(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}

float noise(float2 p) {
    float2 i = floor(p);
    float2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);

    float a = hash(i);
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));

    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

/**
 * Bruit fractal pour plus de détails
 */
float fbm(float2 p) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    const int fixedOctaves = 4;

    for (int i = 0; i < fixedOctaves; i++) {
        value += amplitude * noise(p * frequency);
        amplitude *= 0.5;
        frequency *= 2.0;
    }
    return value;
}

/**
 * Fonction rainbow améliorée avec plus de contrôle
 */
half3 enhancedRainbow(float t, float saturation) {
    t = fract(t);

    // Utilisation d'une fonction HSV vers RGB plus précise
    float h = t * 6.0;
    float c = saturation;
    float x = c * (1.0 - abs(fract(h * 0.5) * 2.0 - 1.0));

    half3 color;
    if (h < 1.0) color = half3(c, x, 0.0);
    else if (h < 2.0) color = half3(x, c, 0.0);
    else if (h < 3.0) color = half3(0.0, c, x);
    else if (h < 4.0) color = half3(0.0, x, c);
    else if (h < 5.0) color = half3(x, 0.0, c);
    else color = half3(c, 0.0, x);

    return color;
}

/**
 * Calcul des normales perturbées pour le micro-relief
 */
float3 calculatePerturbedNormal(float2 uv, float3 baseNormal) {
    // Plusieurs couches de détails
    float microDetail = fbm(uv * uMicroDetailScale) * 0.5;
    float fineDetail = fbm(uv * uMicroDetailScale * 2.0) * 0.3;

    // Gradients pour les directions X et Y
    float2 texelSize = 1.0 / uResolution;
    float heightL = fbm((uv - float2(texelSize.x, 0.0)) * uMicroDetailScale);
    float heightR = fbm((uv + float2(texelSize.x, 0.0)) * uMicroDetailScale);
    float heightD = fbm((uv - float2(0.0, texelSize.y)) * uMicroDetailScale);
    float heightU = fbm((uv + float2(0.0, texelSize.y)) * uMicroDetailScale);

    // Calcul des normales basées sur les gradients
    float3 normal = baseNormal;
    normal.x += (heightL - heightR) * uNormalStrength;
    normal.y += (heightD - heightU) * uNormalStrength;
    normal.z += microDetail * uNormalStrength * 0.5;

    return normalize(normal);
}

/**
 * Modèle d'éclairage PBR (Physically Based Rendering)
 */
half3 calculatePBRLighting(float3 normal, float3 viewDir, float3 lightDir, half3 baseColor, float metallic, float roughness) {
    float3 halfVector = normalize(lightDir + viewDir);

    // Paramètres du matériau
    half3 F0 = mix(half3(0.04), baseColor, metallic);

    // Distribution normale (GGX)
    float NdotH = max(0.0, dot(normal, halfVector));
    float alpha = roughness * roughness;
    float alpha2 = alpha * alpha;
    float denom = NdotH * NdotH * (alpha2 - 1.0) + 1.0;
    float D = alpha2 / (PI * denom * denom);

    // Fonction de géométrie
    float NdotV = max(0.0, dot(normal, viewDir));
    float NdotL = max(0.0, dot(normal, lightDir));
    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
    float G1V = NdotV / (NdotV * (1.0 - k) + k);
    float G1L = NdotL / (NdotL * (1.0 - k) + k);
    float G = G1V * G1L;

    // Fresnel
    float VdotH = max(0.0, dot(viewDir, halfVector));
    half3 F = F0 + (1.0 - F0) * pow(1.0 - VdotH, uFresnelPower);

    // BRDF
    half3 specular = (D * G * F) / (4.0 * NdotV * NdotL + 0.001);
    half3 diffuse = baseColor * (1.0 - F) * (1.0 - metallic);

    return (diffuse + specular) * NdotL;
}

/**
 * Effet de subsurface scattering
 */
half3 calculateSubsurfaceScattering(half3 baseColor, float3 normal, float3 viewDir, float3 lightDir, float thickness) {
    // Calcul de la rétrodiffusion
    float3 scatterDir = lightDir + normal * 0.3;
    float backScatter = max(0.0, dot(viewDir, -scatterDir));

    // Intensité du scattering basée sur l'épaisseur
    float scatterStrength = pow(backScatter, 8.0) * thickness;

    // Couleur chaude du subsurface
    half3 scatterColor = half3(1.0, 0.8, 0.6);

    return mix(baseColor, scatterColor, scatterStrength * uSubsurfaceStrength);
}

/**
 * Effet arc-en-ciel multicouche ultra-réaliste
 */
half3 calculateMultiLayerRainbow(float2 uv, float3 viewDir, float time) {
    float2 centeredUv = uv - 0.5;
    centeredUv.x *= uAspectRatio;

    // Plusieurs couches de spectre avec différentes orientations
    float shift1 = dot(centeredUv, viewDir.xy) * uRainbowScale + time * 0.1 + uRainbowOffset;
    float shift2 = dot(centeredUv * 1.2, float2(viewDir.y, -viewDir.x)) * uRainbowScale * 0.8 + time * 0.15;
    float shift3 = length(centeredUv) * uRainbowScale * 1.5 + time * 0.2;

    // Ajout de bruit pour plus de complexité
    shift1 += fbm(uv * 8.0 + time * 0.1) * 0.3;
    shift2 += fbm(uv * 12.0 + time * 0.15) * 0.2;
    shift3 += fbm(uv * 6.0 + time * 0.2) * 0.4;

    // Combinaison des couches avec des intensités différentes
    half3 rainbow1 = enhancedRainbow(shift1, 0.8) * 0.4;
    half3 rainbow2 = enhancedRainbow(shift2, 0.9) * 0.3;
    half3 rainbow3 = enhancedRainbow(shift3, 0.7) * 0.3;

    return rainbow1 + rainbow2 + rainbow3;
}

/**
 * Paillettes avancées avec mouvement
 */
float calculateAdvancedSparkles(float2 uv, float time, float intensity) {
    // Plusieurs tailles de paillettes
    float sparkle1 = fbm(uv * uSparkleDensity + time * uSparkleSpeed);
    float sparkle2 = fbm(uv * uSparkleDensity * 1.5 + time * uSparkleSpeed * 0.8);
    float sparkle3 = fbm(uv * uSparkleDensity * 2.5 + time * uSparkleSpeed * 1.2);

    // Concentration des paillettes
    sparkle1 = pow(sparkle1, uSparklePower);
    sparkle2 = pow(sparkle2, uSparklePower * 0.8);
    sparkle3 = pow(sparkle3, uSparklePower * 1.2);

    // Combinaison avec des intensités différentes
    float finalSparkle = sparkle1 * 0.5 + sparkle2 * 0.3 + sparkle3 * 0.2;

    return finalSparkle * intensity;
}

/**
 * Fonction principale du shader
 */
half4 main(float2 fragCoord) {
    // Normalisation des coordonnées
    float2 uv = fragCoord / uResolution;
    float2 centeredUv = uv - 0.5;
    centeredUv.x *= uAspectRatio;

    // Échantillonnage de l'image originale
    half4 originalColor = inputShader.eval(fragCoord);

    // --- ÉTAPES DE DEBUG ---
    // DÉCOMMENTE UNE SEULE LIGNE 'return' À LA FOIS POUR DÉBOGUER !

    // Étape 1: Image originale
    // Si noir → problème avec inputShader
    // Attendu: Ton image originale
    // return originalColor;

    // Étape 2: Test couleur solide
    // Si noir → problème compilation shader
    // Attendu: Écran rouge uni
    // return half4(1.0, 0.0, 0.0, 1.0);

    // Étape 3: Visualisation du temps
    // Si pas de variation → problème uTime
    // Attendu: Couleur qui change avec le temps
     //return half4(sin(uTime) * 0.5 + 0.5, 0.0, 0.0, 1.0);

    // Étape 4: Test des capteurs
    // Si pas de variation → problème capteurs
    // Attendu: Rouge varie avec pitch, vert avec roll
    // return half4(uTiltPitch * 0.5 + 0.5, uTiltRoll * 0.5 + 0.5, 0.0, 1.0);

    // Calcul de la direction de vue
    float3 viewDirection = normalize(float3(uTiltRoll * 3.0, uTiltPitch * 2.0, 1.0));

    // Étape 5: Visualisation direction de vue
    // Attendu: Couleur change avec orientation
    // return half4(viewDirection.x * 0.5 + 0.5, viewDirection.y * 0.5 + 0.5, 0.0, 1.0);

    // Normale de base et perturbée
    float3 baseNormal = float3(0.0, 0.0, 1.0);
    float3 perturbedNormal = calculatePerturbedNormal(uv, baseNormal);

    // Étape 6: Visualisation des normales perturbées
    // Attendu: Surface avec texture de bruit subtile
    // return half4(perturbedNormal * 0.5 + 0.5, 1.0);

    // Direction de lumière (simulation)
    float3 lightDirection = normalize(float3(0.5, 0.5, 1.0));

    // Calcul PBR
    half3 pbrLighting = calculatePBRLighting(
        perturbedNormal,
        viewDirection,
        lightDirection,
        originalColor.rgb,
        0.8, // Métallique pour effet holographique
        uRoughness
    );

    // Étape 7: Visualisation PBR seul
    // Attendu: Éclairage métallique réaliste
    // return half4(pbrLighting, 1.0);

    // Calcul du rainbow multicouche
    half3 rainbowEffect = calculateMultiLayerRainbow(uv, viewDirection, uTime);

    // Étape 8: Visualisation rainbow seul
    // Attendu: Couleurs arc-en-ciel qui bougent
    // return half4(rainbowEffect, 1.0);

    // Intensité de réflexion avec Fresnel
    float fresnel = pow(1.0 - max(0.0, dot(perturbedNormal, viewDirection)), uFresnelPower);
    float reflectionIntensity = fresnel * uEffectIntensity;

    // Étape 9: Visualisation Fresnel
    // Attendu: Contours brillants, centre sombre
    // return half4(reflectionIntensity, reflectionIntensity, reflectionIntensity, 1.0);

    // Modulation du rainbow par la réflexion
    rainbowEffect *= reflectionIntensity;

    // Étape 10: Rainbow modulé par Fresnel
    // Attendu: Arc-en-ciel principalement sur les bords
    // return half4(rainbowEffect, 1.0);

    // Subsurface scattering
    half3 subsurfaceEffect = calculateSubsurfaceScattering(
        originalColor.rgb,
        perturbedNormal,
        viewDirection,
        lightDirection,
        uSubsurfaceThickness
    );

    // Étape 11: Visualisation subsurface
    // Attendu: Image avec effet de profondeur chaud
    // return half4(subsurfaceEffect, 1.0);

    // Aberration chromatique
    float aberrationAmount = reflectionIntensity * uChromaticAberrationStrength;
    half4 rChannel = inputShader.eval(fragCoord + float2(aberrationAmount * uResolution.x, 0.0));
    half4 gChannel = inputShader.eval(fragCoord);
    half4 bChannel = inputShader.eval(fragCoord - float2(aberrationAmount * uResolution.x, 0.0));
    half4 chromaticColor = half4(rChannel.r, gChannel.g, bChannel.b, originalColor.a);

    // Étape 12: Visualisation aberration chromatique
    // Attendu: Image avec franges colorées
    // return chromaticColor;

    // Combinaison des effets
    half3 baseEffect = mix(subsurfaceEffect, chromaticColor.rgb, 0.5);
    half3 combinedEffect = mix(baseEffect, rainbowEffect, reflectionIntensity);

    // Étape 13: Effets combinés sans paillettes
    // Attendu: Effet holographique complet mais sans scintillement
    // return half4(combinedEffect, 1.0);

    // Paillettes avancées
    float sparkleEffect = calculateAdvancedSparkles(uv, uTime, uSparkleIntensity);
    sparkleEffect *= reflectionIntensity; // Modulation par la réflexion

    // Étape 14: Visualisation paillettes seules
    // Attendu: Points brillants qui scintillent
    // return half4(sparkleEffect, sparkleEffect, sparkleEffect, 1.0);

    // Ajout des paillettes au résultat final
    combinedEffect += half3(sparkleEffect, sparkleEffect, sparkleEffect);

    // Pulsation subtile
    float pulse = 1.0 + sin(uTime * 2.0) * uPulseIntensity;
    combinedEffect *= pulse;

    // Étape 15: Effet final avec pulsation
    // Attendu: Effet complet avec légère pulsation
    // return half4(combinedEffect, 1.0);

    // Limitation des valeurs et résultat final
    combinedEffect = clamp(combinedEffect, 0.0, 1.0);

    // RÉSULTAT FINAL
    return half4(combinedEffect, originalColor.a);
}