// This is the input texture/bitmap that will be deformed with holographic effect.
// It's typically the content of the Composable the shader is applied to.
uniform shader inputShader;

// The resolution (width, height) of the area where the shader is applied, in pixels.
uniform float2 uResolution;

// New tilt parameters from the accelerometer, normalized (e.g., -1.0 to 1.0)
uniform float uTiltPitch; // Tilt forward/backward
uniform float uTiltRoll;  // Tilt left/right

// Overall intensity of the foil effect (0.0 to 1.0+)
uniform float uEffectIntensity;

// Controls the sharpness/intensity of the specular reflection
uniform float uShininess;

// Adjusts the spread and offset of rainbow colors based on angle
uniform float uRainbowScale;
uniform float uRainbowOffset;

// Parameters for internal patterns (e.g., lines, dots)
uniform float uPatternDensity;
uniform float uPatternVisibility;

// Parameters for sparkle highlights
uniform float uSparkleDensity;
uniform float uSparklePower;
uniform float uSparkleIntensity;

// Strength of chromatic aberration
uniform float uChromaticAberrationStrength;

// Aspect ratio for proper coordinate normalization
uniform float uAspectRatio;

// Define PI for mathematical calculations
float PI = 3.141592653589793;

/**
 * Generate a rainbow color based on a normalized value (0.0 to 1.0)
 * Creates smooth transitions through the spectrum
 */
half3 rainbow(float t) {
    t = fract(t); // Ensure t is in [0, 1]
    float r = abs(t * 6.0 - 3.0) - 1.0;
    float g = 2.0 - abs(t * 6.0 - 2.0);
    float b = 2.0 - abs(t * 6.0 - 4.0);
    return clamp(half3(r, g, b), 0.0, 1.0);
}

/**
 * Create a smooth noise function for organic patterns
 */
float noise(float2 p) {
    return fract(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}

/**
 * Smooth noise function with interpolation
 */
float smoothNoise(float2 p) {
    float2 i = floor(p);
    float2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f); // Smooth interpolation

    float a = noise(i);
    float b = noise(i + float2(1.0, 0.0));
    float c = noise(i + float2(0.0, 1.0));
    float d = noise(i + float2(1.0, 1.0));

    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

/**
 * The main entry point for the fragment shader. This function is executed for every pixel
 * on the screen (or the target drawing surface).
 *
 * @param fragCoord The absolute (x, y) coordinate of the current pixel being processed, in pixels.
 * @return The final color for the current pixel with foil effect applied.
 */
half4 main(float2 fragCoord) {
    // Normalize coordinates to [0, 1] range
    float2 uv = fragCoord / uResolution;

    // Adjust for aspect ratio and center coordinates
    float2 centeredUv = uv - 0.5;
    centeredUv.x *= uAspectRatio;

    // Sample the original image
    half4 originalColor = inputShader.eval(fragCoord);

    // --- DEBUGGING STAGES ---
    // UNCOMMENT ONLY ONE 'return' LINE AT A TIME TO DEBUG!

    // Stage 1: Basic Image Display
    // If this is black, the inputShader or basic setup is broken.
    // Expected: Your original image.
    // return originalColor;

    // Stage 2: Solid Color Test
    // If this is black, the shader itself is not being applied or compiled correctly.
    // Expected: A solid red screen.
    // return half4(1.0, 0.0, 0.0, 1.0);

    // Stage 3: Raw uTiltPitch and uTiltRoll visualization
    // This tests if the tilt uniforms are correctly received and vary.
    // Expected: Screen should change color (red for pitch, green for roll) as you tilt the device.
    //           Red (pitch): From black (min pitch) to full red (max pitch).
    //           Green (roll): From black (min roll) to full green (max roll).
     //return half4(uTiltPitch * 0.5 + 0.5, 0.0, 0.0, 1.0); // Visualize uTiltPitch (Red channel)
  //   return half4(0.0, uTiltRoll * 0.5 + 0.5, 0.0, 1.0);  // Visualize uTiltRoll (Green channel)


    // Stage 4: Visualize X component of viewDirection
    // Expected: Should vary as you roll the device.
    float3 viewDirection = normalize(float3(uTiltRoll * 5.0, uTiltPitch * 3.0, 1.0));
   //  return half4(viewDirection.x * 0.5 + 0.5, 0.0, 0.0, 1.0);


    // Stage 5: Visualize Y component of viewDirection
    // Expected: Should vary as you pitch the device.
    // return half4(0.0, viewDirection.y * 0.5 + 0.5, 0.0, 1.0);


    // Stage 6: Visualize the dot product directly, WITHOUT pow or max
    // This should vary between positive and negative values as you tilt.
    float3 surfaceNormal = float3(0.0, 0.0, 1.0);
    float rawDotProduct = dot(surfaceNormal, viewDirection);
    // Expected: Screen should vary from dark (negative dot) to bright (positive dot) as you tilt.
   //  return half4(rawDotProduct * 0.5 + 0.5, rawDotProduct * 0.5 + 0.5, rawDotProduct * 0.5 + 0.5, 1.0);


   // Stage 7: Visualize reflectionStrength with a lower uShininess (e.g., 5.0 instead of 150.0)
   // Expected: A large white/gray blob that moves and changes intensity as you tilt.
   //           It should be brightest when the phone is flat (facing you).
   float debugShininess = 5.0; // TEMPORARY for debugging
   float reflectionStrength = pow(max(0.0, dot(surfaceNormal, viewDirection)), debugShininess);
   //return half4(reflectionStrength, reflectionStrength, reflectionStrength, 1.0);


    // Stage 8: Raw Rainbow Color (without reflection strength modulation)
    // This tests the rainbow function and spectralShift calculation.
    // Expected: Moving rainbow patterns across the screen, independent of tilt intensity.
    float spectralShift = dot(centeredUv, viewDirection.xy * 0.8) * uRainbowScale + uRainbowOffset;
    spectralShift += smoothNoise(uv * 5.0) * 0.1;
    half3 spectrumColor = rainbow(spectralShift);
    //return half4(spectrumColor, 1.0);


    // Stage 9: Rainbow Color Modulated by Reflection Strength
    // This tests if the rainbow effect is correctly combined with reflection strength.
    // Expected: Rainbow colors appearing only in the bright areas determined by tilt.
    spectrumColor *= reflectionStrength;
    // return half4(spectrumColor, 1.0);



    // Stage 10: Chromatic Aberration Only
    // This tests if chromatic aberration is applied correctly to the original image.
    // Expected: Your original image with color fringing, especially in high-contrast areas.
    float aberrationAmount = reflectionStrength * uChromaticAberrationStrength;
    half4 rShift = inputShader.eval(fragCoord + float2(aberrationAmount, 0.0));
    half4 gShift = inputShader.eval(fragCoord);
    half4 bShift = inputShader.eval(fragCoord - float2(aberrationAmount, 0.0));
    half4 chromaticColor = half4(rShift.r, gShift.g, bShift.b, originalColor.a);
    //return chromaticColor;


    // Stage 11: Final Mix without Sparkles
    // This tests the main blending of chromatic image and spectrum.
    // Expected: Your image with the full foil effect, but without the tiny sparkle highlights.
    half3 finalColor = mix(chromaticColor.rgb, spectrumColor, reflectionStrength * uEffectIntensity);
    // return half4(finalColor, originalColor.a);


    // Stage 12: Full Final Output (Original Code)
    // If all above worked, this should work too.
    // Expected: The complete foil effect with sparkles.
    float sparkle = smoothNoise(uv * uSparkleDensity);
    sparkle = pow(sparkle, uSparklePower) * reflectionStrength;
    finalColor += half3(sparkle, sparkle, sparkle) * uSparkleIntensity;

    finalColor = clamp(finalColor, 0.0, 1.0);
    return half4(finalColor, originalColor.a);
}